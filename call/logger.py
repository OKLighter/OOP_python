"""
Реализация метода __call__ нужна, когда мы хотим, чтобы экземпляры класса вели себя как функции.
Одна из реальных ситуаций, когда такое может быть полезно — это создание утилиты ведения журнала,
которую можно легко настроить и вызывать из любых частей вашей программы.
Предположим, что у вас есть программа с несколькими модулями и функциями,
выполнение которых вы хотите регистрировать.
Вместо создания отдельного экземпляра ведения журнала для каждого модуля или функции
вы можете создать класс ведения журнала с методом __call__,
который можно использовать для регистрации сообщений с помощью одной строки кода.

Вот пример того, как это может быть реализовано:
"""


class Logger:
    def __init__(self, log_file):
        self.log_file = log_file

    def __call__(self, message):
        with open(self.log_file, 'a') as f:
            f.write(message + '\n')


"""
С помощью этого класса вы можете создать экземпляр логгера и использовать его для регистрации сообщений
из любой части вашей программы. Например:
"""

from datetime import datetime

logger = Logger('my_log_file.txt')


def get_information():
    logger(f'Start work in get_information: {datetime.now()}')
    # do some work
    logger(f'Finished work in get_information: : {datetime.now()}')


def delete_files():
    logger(f'Start work in {delete_files.__name__}: {datetime.now()}')
    # do some work
    logger(f'Finished work in {delete_files.__name__}: : {datetime.now()}')


"""
В этом примере logger вызывается со строкой сообщения, которая записывается в указанный файл журнала логирования. 
Это упрощает отслеживание того, что происходит в разных частях программы, 
без необходимости создавать несколько экземпляров журнала и управлять ими.
"""
